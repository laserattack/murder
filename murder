#!/usr/bin/env perl

# What is it : Linux process killer script
# Usage      : murder [-hfqonc] PID|NAME|:PORT

use strict;
use Getopt::Long;

BEGIN {
    eval "use warnings";
    eval "use Time::HiRes 'sleep'";
    if ($@) {
         *sleep = sub {
            my $seconds = shift;
            CORE::sleep($seconds) if $seconds > 0;
        };
    }
}

my @SIGNALS = (
    # [signal, timeout]
    [15, 3],
    [2, 3],
    [1, 4],
    [9, 0]
);

# flags
Getopt::Long::Configure('bundling'); # can combine flags e.g., -qf
my $FORCE    = 0;
my $QUIET    = 0;
my $HELP     = 0;
my $ONE      = 0;
my $DRYRUN   = 0;
my $NAMEONLY = 0;

sub log_message {
    print @_, "\n" unless $QUIET;
}

sub go_ahead {
    chomp(my $input = <STDIN>);
    $input    =~ s/^\s+|\s+$//g;
    $input    = lc($input);

    return 1 if $input eq '';
    return $input =~ /^(y|yes|yas)$/? 1: 0;
}

sub is_running {
    my ($pid) = @_;
    return kill(0, $pid);
}

sub get_children {
    my ($pid) = @_;
    local *DIR;
    opendir(DIR, '/proc') or return;
    my @children;

    while (readdir(DIR)) {
        next unless /^\d+$/;

        if (open(STAT, "/proc/$_/stat")) {
            my $stat = <STAT>;
            close STAT;
            my ($ppid) = ($stat =~ /^.*\)\s+.\s+(\d+)/);
            push @children, $_ if (defined $ppid && $ppid == $pid);
        }
    }

    closedir DIR;
    return @children;
}

sub get_pid_with_start {
    my ($pid) = @_;
    chomp(my $start = `ps -o lstart= -p $pid 2>/dev/null`);
    return ($pid, $start);
}

sub get_all_descendants {
    my ($pid) = @_;
    my %result; # hash: pid => start_time
    my @queue = ($pid);

    my ($self_pid, $self_start) = get_pid_with_start($pid);
    $result{$self_pid} = $self_start if $self_start;

    while (my $current = shift @queue) {
        my @children = get_children($current);
        foreach my $child (@children) {
            next if exists $result{$child};

            my ($child_pid, $child_start) = get_pid_with_start($child);
            if ($child_start) {
                $result{$child_pid} = $child_start;
                push @queue, $child;
            }
        }
    }

    return %result;
}

sub verify_process {
    my ($pid, $original_start) = @_;
    chomp (my $current_start = `ps -o lstart= -p $pid 2>/dev/null`);
    return $current_start eq $original_start;
}

sub kill_process_single {
    return if $DRYRUN;
    my ($pid, $original_start) = @_;
    return if !is_running($pid) || !verify_process($pid, $original_start);
    foreach my $sig (@SIGNALS) {
        my ($code, $wait) = @$sig;
        log_message "Sending signal $code to pid $pid";
        kill($code, $pid);
        sleep(0.3);
        last if !is_running($pid) || !verify_process($pid, $original_start);
        sleep($wait);
        last if !is_running($pid) || !verify_process($pid, $original_start);
    }
}

sub kill_process_tree {
    my ($pid) = @_;

    if ($ONE) {
        log_message "Process: $pid";
        my ($self_pid, $self_start) = get_pid_with_start($pid);
        kill_process_single($self_pid, $self_start);
        return;
    }

    my %pids_with_start = get_all_descendants($pid);
    my @all_pids        = keys %pids_with_start;

    my @all_pids_with_names = map {
        chomp(my $name = `ps -p $_ -o comm= 2>/dev/null`);
        "$_($name)"
    } @all_pids;
    log_message "Process tree: ".join(', ', @all_pids_with_names);

    foreach my $target_pid (reverse @all_pids) {

        my $exists = is_running($target_pid);

        # exists, but another process on the pid
        if ($exists && !verify_process($target_pid, $pids_with_start{$target_pid})) {
            log_message "Process with pid $target_pid changed";
            next;
        }

        # no exists ??
        unless ($exists) {

            # mb exists but no rights?
            my $no_rights = do {
                my @lines = split(/\n/, `ps -p $target_pid 2>/dev/null`);
                scalar @lines == 2
            };

            if ($no_rights) {
                # exists but no rights
                log_message "There are no rights to send a signal to $target_pid";
            } else {
                # no exists
                log_message "Process with pid $target_pid already dead";
            }
            next;
        }

        kill_process_single($target_pid, $pids_with_start{$target_pid});
    }
}

sub murder_pid {
    my ($pid) = @_;
    return unless is_running $pid;
    chomp(my $name  = `ps -p $pid -o comm= 2>/dev/null`);
    print("Kill process $name (pid $pid)? [Y/n] ");
    if ($FORCE) {
        print("\n");
        kill_process_tree($pid);
    } else {
        kill_process_tree($pid) if go_ahead();
    }
}

sub murder_port {
    my ($port) = @_;
    $port =~ s/^://;

    # try ss
    my @pids = do {
        my $ss_out = `ss -ltnup 'sport = :$port' 2>/dev/null`;
        $ss_out =~ /pid=(\d+)/g
    };
    my %seen;
    @pids = grep { !$seen{$_}++ } @pids; # mb ipv4-ipv6 duplicates

    # try lsof
    @pids = split(/\n/, `lsof -ti:$port 2>/dev/null`) unless @pids;

    foreach my $pid (@pids) {
        murder_pid($pid);
    }
}

sub murder_names {
    my ($name) = @_;

    my $output = do {
        my $format = $NAMEONLY? 'pid comm': 'pid command';
        `ps -eo '$format' 2>/dev/null`
    };

    foreach my $line (split(/\n/, $output)) {
        my ($pid, $cmd_or_name) = $line =~ /^\s*(\d+)\s+(.+)/;
        next unless $pid && $cmd_or_name;
        next if $pid == $$;
        # \Q...\E escapes regex metacharacters (treats $name as literal string)
        next unless $cmd_or_name =~ /\Q$name\E/;
        murder_pid($pid);
    }
}

sub murder {
    my ($arg) = @_;
    if ($arg =~ /^\d+$/) {
        murder_pid($arg);
    } elsif ($arg =~ /^:\d+$/) {
        murder_port($arg);
    } else {
        murder_names($arg);
    }
}

sub main {
    if (@ARGV < 1) {
        usage();
    } else {
        foreach my $arg (@ARGV) {
            murder($arg);
        }
    }
}

sub usage {
    print "What is it : Linux process killer script",                                  "\n";
    print "Usage      : murder [-hfqonc] PID|NAME|:PORT",                              "\n";
    print "",                                                                          "\n";
    print "Flags:",                                                                    "\n";
    print "  -h, --help       Show this help message",                                 "\n";
    print "  -f, --force      Kill without confirmation",                              "\n";
    print "  -q, --quiet      Quiet mode (minimal output)",                            "\n";
    print "  -o, --one        Kill only the specified process, not the entire tree",   "\n";
    print "  -c, --name-only  Search by process name only (not full command line)",    "\n";
    print "  -n, --dry-run    Show what would be killed without actually killing",     "\n";
    print "",                                                                          "\n";
    print "Arguments:",                                                                "\n";
    print "  PID    Process ID to kill",                                               "\n";
    print "  NAME   Process name to kill (e.g., python, emacs, firefox)",              "\n";
    print "  :PORT  Port number to kill process on (e.g., :3000)",                     "\n";
    print "",                                                                          "\n";
    print "Examples:",                                                                 "\n";
    print "  murder 1234          Kill process with PID 1234",                         "\n";
    print "  murder -f ruby       Kill all ruby processes without asking",             "\n";
    print "  murder :3000         Kill process on port 3000 quietly",                  "\n";
    print "  murder -nfq firefox  Show what would be killed with minimal output",      "\n";
    print "",                                                                          "\n";
    print "For more details, see man page",                                            "\n";
}

GetOptions(
    'force|f'     => \$FORCE,
    'quiet|q'     => \$QUIET,
    'help|h'      => \$HELP,
    'one|o'       => \$ONE,
    'dry-run|n'   => \$DRYRUN,
    'name-only|c' => \$NAMEONLY,
    ) or do {
        usage();
        exit 1;
};

my $has_ss   = `which ss 2>/dev/null`;
my $has_lsof = `which lsof 2>/dev/null`;

if (!$QUIET && !$has_ss && !$has_lsof) {
    print STDERR "WARNING: Neither 'ss' nor 'lsof' found. Port killing mode (:PORT) will not work\n";
}

if ($HELP) {
    usage();
    exit 1;
}

main();
