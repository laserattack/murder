#!/usr/bin/env perl

use strict;
use warnings;
use feature 'say';
use Time::HiRes 'sleep';
use Getopt::Long;

our @SIGNALS = (
    # [signal, timeout]
    [15, 3],
    [2, 3],
    [1, 4],
    [9, 0]
);

# flags
Getopt::Long::Configure('bundling'); # can combine flags e.g., -qf
our $FORCE    = 0;
our $QUIET    = 0;
our $HELP     = 0;
our $ONE      = 0;
our $DRYRUN   = 0;
our $NAMEONLY = 0;

sub log_message {
    say @_ unless $QUIET;
}

sub go_ahead {
    my $input = <STDIN>;
    chomp($input);
    $input    =~ s/^\s+|\s+$//g;
    $input    = lc($input);

    return 1 if $input eq '';
    return $input =~ /^(y|yes|yas)$/ ? 1 : 0;
}

sub is_running {
    my ($pid) = @_;
    return `ps -p $pid` =~ tr/\n// == 2;
}

sub get_all_descendants {
    my ($pid) = @_;
    my %result;

    my $find_children;
    $find_children = sub {
        my ($parent) = @_;
        my @children = split(/\n/, `ps -eo pid,ppid | awk '\$2 == $parent {print \$1}'`);
        foreach my $child (@children) {
            next if $result{$child}++;
            $find_children->($child);
        }
    };

    $find_children->($pid);
    return keys %result;
}

sub kill_process_single {
    return if $DRYRUN;
    my ($pid) = @_;
    foreach my $sig (@SIGNALS) {
        my ($code, $wait) = @$sig;
        log_message "Sending signal $code to pid $pid";
        kill($code, $pid);
        sleep(0.3);
        last unless is_running($pid);
        sleep($wait);
    }
}

sub kill_process_tree {
    my ($pid) = @_;

    if ($ONE) {
        log_message "Process: $pid";
        kill_process_single($pid);
        return;
    }

    my @all_pids = get_all_descendants($pid);
    unshift @all_pids, $pid;

    my @all_pids_with_names = map {
        chomp(my $name = `ps -p $_ -o comm= 2>/dev/null`);
        "$_($name)"
    } @all_pids;
    log_message "Process tree: ".join(', ', @all_pids_with_names);

    foreach my $target_pid (reverse @all_pids) {
        unless (is_running($target_pid)) {
            log_message "Process with pid $target_pid already dead";
            next;
        }
        kill_process_single($target_pid);
    }
}

sub murder_pid {
    my ($pid) = @_;
    my $name  = `ps -p $pid -o comm=`;
    chomp($name);
    print("Kill process $name (pid $pid)? [Y/n] ");
    if ($FORCE) {
        print("\n");
        kill_process_tree($pid);
    } else {
        kill_process_tree($pid) if go_ahead();
    }
}

sub murder_port {
    my ($port) = @_;
    $port      =~ s/^://;
    my @pids   = split(/\n/, `lsof -ti:$port`);
    foreach my $pid (@pids) {
        murder_pid($pid);
    }
}

sub murder_names {
    my ($name)  = @_;
    my $format  = $NAMEONLY ? 'pid comm' : 'pid command';
    my $running = `ps -eo '$format' | grep -Fiw '$name' | grep -Fv grep`;
    foreach my $line (split(/\n/, $running)) {
        my ($pid) = $line =~ /^\s*(\d+)/;
        next if $$ == $pid;
        murder_pid($pid);
    }
}

sub murder {
    my ($arg) = @_;
    if ($arg =~ /^\d+$/) {
        murder_pid($arg);
    } elsif ($arg =~ /^:\d+$/) {
        murder_port($arg);
    } else {
        murder_names($arg);
    }
}

sub main {
    if (@ARGV < 1) {
        usage();
    } else {
        foreach my $arg (@ARGV) {
            murder($arg);
        }
    }
}

sub usage {
    say "What is it : Linux process killer script";
    say "Usage      : murder [-hfqonc] arguments";
    say "";
    say "Flags:";
    say "  -h, --help       Show this help message";
    say "  -f, --force      Kill without confirmation";
    say "  -q, --quiet      Quiet mode (minimal output)";
    say "  -o, --one        Kill only the specified process, not the entire tree";
    say "  -c, --name-only  Search by process name only (not full command line)";
    say "  -n, --dry-run    Show what would be killed without actually killing";
    say "";
    say "Arguments:";
    say "  PID    Process ID to kill";
    say "  NAME   Process name to kill (e.g., python, emacs, firefox)";
    say "  :PORT  Port number to kill process on (e.g., :3000)";
    say "";
    say "Examples:";
    say "  murder 1234          Kill process with PID 1234";
    say "  murder -f ruby       Kill all ruby processes without asking";
    say "  murder -q :3000      Kill process on port 3000 quietly";
    say "  murder -fq python    Kill python processes without asking and quietly";
    say "  murder -nf firefox   Show what would be killed (search by full command)";
    say "  murder -nfc firefox  Show what would be killed (search by name only)";
    say "  murder -nfq firefox  Show what would be killed with minimal output";
}

GetOptions(
    'force|f'     => \$FORCE,
    'quiet|q'     => \$QUIET,
    'help|h'      => \$HELP,
    'one|o'       => \$ONE,
    'dry-run|n'   => \$DRYRUN,
    'name-only|c' => \$NAMEONLY,
    ) or do {
        usage();
        exit 1;
};

if ($HELP) {
    usage();
    exit 1;
}

main();
